%{
#import <Tranquil/Tranquil.h>

struct _TQParserState {
    NSRange currentToken;
    int currentLine;

    NSMutableArray *stack;
    TQProgram *program;

    FILE *stream;
};
typedef struct _TQParserState TQParserState;

#define YY_XTYPE TQParserState *
#define YY_XVAR  state
#define YYSTYPE id
#define YYNSSTR [NSString stringWithUTF8String:yytext]
#define YYNUM atof(yytext)
#define YYNSNUM [NSNumber numberWithDouble:YYNUM]

#define StackTop [state->stack lastObject]
#define StackGet(ofs) [state->stack objectAtIndex:[state->stack count] + (ofs) - 1]
#define PushStack(obj) [state->stack addObject:(obj)]
#define PopStack() StackTop; [state->stack removeLastObject]
#define ReplaceStackTop(val) do { id repl = val; PopStack(); PushStack(repl); } while(0)

#define UpdateToken() do { \
    ((TQParserState *)state)->currentToken.location  = thunk->begin + G->offset;  \
    ((TQParserState *)state)->currentToken.length    = thunk->end - thunk->begin; \
} while(0)

#define ExtendToken() do { \
    ((TQParserState *)state)->currentToken.length += thunk->end - thunk->begin; \
} while(0)


#define SyntaxError(msg) do { \
    NSString *source = [NSString stringWithUTF8String:G->buf]; \
        NSRange tokRange         = state->currentToken; \
        NSRange interestingRange = NSIntersectionRange(NSMakeRange(0, [source length]), NSMakeRange(tokRange.location - 10, tokRange.length + 20)); \
        if(interestingRange.length > 0) { \
            NSMutableString *errStr = [[[source substringWithRange:interestingRange] mutableCopy] autorelease]; \
            NSLog(@"%@", errStr);\
            NSRange errRange = NSMakeRange(tokRange.location - interestingRange.location, tokRange.length); \
            [errStr insertString:@" >> " atIndex:errRange.location]; \
            [errStr insertString:@" << " atIndex:NSMaxRange(errRange) + 4]; \
            NSLog(@"Syntax error! %@ near %@", (msg), errStr); \
        } else \
            NSLog(@"Syntax error! %@", (msg)); \
    exit(1); \
} while(0)

//#define YY_DEBUG

#define YY_INPUT(buf, result, maxSize, state) yyInput(buf, &result, maxSize, state)

void yyInput(char *buf, int *result, int maxSize, TQParserState *state) {
    (*result) = fread(buf, 1, maxSize, state->stream);
    static int doneNewlineHack = 0;
    if((*result) == 0 && doneNewlineHack == 0) {
        doneNewlineHack = 1;
        (*buf) = '\n';
        (*result) = 1;
        return;
    }
}
%}

Program      = -- ((Statement (- '.')?|Comment) --)+ EOF
               {
                   NSMutableArray *statements = PopStack();
                   TQNodeBlock *root = [TQNodeRootBlock node];
                   [root setStatements:statements];
                   [state->program setRoot:root];
               }
             | - ( !EOL . )* EOL { SyntaxError(@"") }


# Statement
Statement    = (
               If
             | Loop
             | BreakStmt
             | SkipStmt
             | ShiftStmt
             | Message
             | Call
             | IncrDecrOp
             | Class
             | Assignment
             | Return
             | InvalidStmt
             ) { [StackTop addObject:$$]; }

InvalidStmt  = Expression            { SyntaxError(@"Unexpected Expression"); }
             | ("=" -- b:Expression) { SyntaxError(@"Unexpected Assignment"); }

Return       = "^" retVal:Expression { UpdateToken(); $$ = [TQNodeReturn nodeWithValue:retVal]; }


# Expression
Expression   = TernaryExpr
             | KeywordMsg
             | Equation
             | Assignment
             | _OtherExpr

NoTernExpr   = Equation
             | _OtherExpr

NoEqExpr     = _OtherExpr

_OtherExpr   = Call
             | Valid
             | UnaryMsg
             | Block
             | UnaryOp
             | Nil
             | SubscriptExp
             | Property
             | RegExp
             | Self
             | Variadic
             | Literal
             | Constant
             | Variable
             | ParenExpr

ParenExpr    = '(' -- expr:Expression -- ')' { ExtendToken(); $$ = expr; }


# Messages
UnaryMsg     = rcvr:UnaryMsgRcvr - name:Identifier - !":"
               {
                    PushStack([TQNodeMessage nodeWithReceiver:rcvr]);
                    [(NSMutableArray*)[StackTop arguments] addObject:[TQNodeArgument nodeWithPassedNode:nil
                                                                                           selectorPart:name]];
               }
               (- extraName:Identifier - !":"
                  {
                      ReplaceStackTop([TQNodeMessage nodeWithReceiver:StackTop]);
                      [(NSMutableArray*)[StackTop arguments] addObject:[TQNodeArgument nodeWithPassedNode:nil
                                                                                             selectorPart:extraName]];

                  }
               )*
               {
                   $$ = PopStack();
               }

KeywordMsg   = rcvr:KwdMsgRcvr -
               {
                    ExtendToken();
                    PushStack([TQNodeMessage nodeWithReceiver:rcvr]);
                    PushStack([NSMutableArray array]);
               }
               (SelectorPart --)+
               {
                    ExtendToken();
                    NSMutableArray *arguments = PopStack();
                    $$ = PopStack();
                    [$$ setArguments:arguments];
               }
Message      = KeywordMsg|UnaryMsg

UnaryMsgRcvr = Call
             | SubscriptExp
             | Property
             | Constant
             | Super
             | Variadic
             | Literal
             | Variable
             | ParenExpr
KwdMsgRcvr   = UnaryMsg
             | UnaryMsgRcvr

SelectorPart = { PushStack([TQNodeArgument node]); }
               (name:SelIdent  { [StackTop setSelectorPart:name]; }) #?
                - ':' -- param:MessageArg
               {
                    ExtendToken();
                    TQNodeArgument *arg = PopStack();
                    [arg setPassedNode:param];
                    [StackTop addObject:arg];
               }
MessageArg   = TernaryExpr
             | Equation
             | Call
             | UnaryMsg
             | Block
             | UnaryOp
             | Nil
             | SubscriptExp
             | Property
             | RegExp
             | Self
             | Literal
             | Constant
             | Variable
             | ParenExpr

# Call
## callee(expr, expr)
Call         = callee:Callee
               {
                    ExtendToken();
                    PushStack([TQNodeCall nodeWithCallee:callee]);
                    PushStack([NSMutableArray array]);
               }
               '(' -- (CallArg (-- ',' -- CallArg)*)? -- ')'
               {
                    ExtendToken();
                    NSMutableArray *arguments = PopStack();
                    $$ = PopStack();
                    [$$ setArguments:arguments];
               }
Callee       = Block
             | Constant
             | SubscriptExp
             | Property
             | Variable
CallArg      = arg:Expression { [StackTop addObject:arg]; }


# Block
Block        = '{' --
               {
                    UpdateToken();
                    PushStack([TQNodeBlock node]);
                    PushStack([NSMutableArray array]);
               }
               ( ( (BlockArgDef - (',' -- BlockArgDef --)* (',' -- BlkVarArgDef --)?) | ( BlkVarArgDef --) )? '|' --)?
               {
                    ExtendToken();
                    NSMutableArray *arguments = PopStack();
                    for(TQNodeArgumentDef *arg in arguments) {
                       [StackTop addArgument:arg error:nil];
                    }
                    PushStack([NSMutableArray array]);
               }
               (Statement --)*
               {
                    NSMutableArray *statements = PopStack();
                    $$ = PopStack();
                    [$$ setStatements:statements];
               }
               '}'
             | '`' -
               {
                   UpdateToken();
                   PushStack([NSMutableArray array]);
               }
               ( (BlockArgDef - (',' -- BlockArgDef --)*)?
               (',' -- BlkVarArgDef --)? -- '|' -)? expr:Expression - '`'
               {
                   ExtendToken();
                   NSMutableArray *arguments = PopStack();
                   $$ = [TQNodeBlock node];
                   [$$ setIsCompactBlock:YES];
                   for(TQNodeArgumentDef *arg in arguments) {
                       [$$ addArgument:arg error:nil];
                   }
                   [$$ setStatements:[NSMutableArray arrayWithObject:[TQNodeReturn nodeWithValue:expr]]];
               }
BlockArgDef  = name:Identifier { [StackTop addObject:[TQNodeArgumentDef nodeWithName:name]]; }
                (- "=" -- default:Expression { [[StackTop lastObject] setDefaultArgument:default]; })? 
BlkVarArgDef = Variadic        { [StackGet(-1) setIsVariadic:YES]; }


# Class
Class        = '#' name:Constant --
               {
                   UpdateToken();
                   PushStack([TQNodeClass nodeWithName:[(TQNodeConstant *)name value]]);
               }
               ( "<" -- SuperClsName -- )? '{' -- (Method --)* '}'
               {
                   ExtendToken();
                   $$ = PopStack();
               }
SuperClsName = superName:Constant
               {
                   ExtendToken();
                   [StackTop setSuperClassName:[(TQNodeConstant *)superName value]];
               }
Method       = '+' -- method:MethodImpl
               {
                   ExtendToken();
                   [(TQNodeMethod *)method setType:kTQClassMethod];
                   [[(TQNodeClass *)StackTop classMethods] addObject:method];
               }
             | '-' -- method:MethodImpl
               {
                   ExtendToken();
                   [(TQNodeMethod *)method setType:kTQInstanceMethod];
                   [[(TQNodeClass *)StackTop instanceMethods] addObject:method];
               }
MethodImpl   = arguments:MethodArgs  --
               {
                   ExtendToken();
                   PushStack([NSMutableArray array]);
               }
               ( '{' -- (Statement --)* '}'
               {
                   NSMutableArray *statements = PopStack();
                   $$ = [TQNodeMethod node];
                   [$$ setStatements:statements];
               }
               | '`' - expr:Expression - '`'
               {
                   ExtendToken();
                   PopStack(); // Ignore
                   $$ = [TQNodeMethod node];
                   [$$ setStatements:[NSMutableArray arrayWithObject:[TQNodeReturn nodeWithValue:expr]]];
               }
               )
               {
                   NSError *err = nil;
                   for(TQNodeMethodArgumentDef *arg in arguments) {
                       [(TQNodeMethod*)$$ addArgument:arg error:&err];
                       if(err)
                           assert(false);
                   }
               }
MethodArgs   = selIdentifier:SelIdent
               {
                   ExtendToken();
                   PushStack([NSMutableArray array]);
                   [StackTop addObject:[TQNodeMethodArgumentDef nodeWithName:nil selectorPart:selIdentifier]];
               }
               (':' -- name:Identifier
                {
                    [[StackTop lastObject] setName:name];
                }
               -- MethodArg*)?
               {
                   ExtendToken();
                   $$ = PopStack();
               }
MethodArg    = identifier:SelIdent':' -- name:Identifier
               {
                   ExtendToken();
                   [StackTop addObject:[TQNodeMethodArgumentDef nodeWithName:name selectorPart:identifier]];
               }


# Conditionals
If           = ( "if"        { UpdateToken();  PushStack([TQNodeIfBlock node]);     }
               | "unless"    { UpdateToken();  PushStack([TQNodeUnlessBlock node]); }
               )
               - cond:Expression --
               {
                   ExtendToken();
                   [StackTop setCondition:cond];
                   PushStack([NSMutableArray array]);
               }
               ('{' -- ( Statement --)* '}' | -- Statement)
               ( -- "else" - elsif:If
                 {
                     [StackGet(-1) setElseBlockStatements:[NSMutableArray arrayWithObject:elsif]];
                 }
               | -- "else" --
                 {
                     PushStack([NSMutableArray array]);
                 }
                 ("{" -- (Statement --)* "}" | -- Statement)
                 {
                     NSMutableArray *statements = PopStack();
                     [StackGet(-1) setElseBlockStatements:statements];
                 }
               )?
               {
                   ExtendToken();
                   NSMutableArray *statements = PopStack();
                   $$ = PopStack();
                   [$$ setStatements:statements];
               }

TernaryExpr    = cond:NoTernExpr --- "?" --- ifExpr:Expression
               {
                   PushStack([TQNodeTernaryOperator node]);
                   [StackTop setCondition:cond];
                   [StackTop setIfExpr:ifExpr];
               }
               (--- ":" --- elseExpr:Expression
                {
                    [StackTop setElseExpr:elseExpr];
                }
               )?
               {
                   $$ = PopStack();
               }

# Loops

Loop         = ( "while"  { UpdateToken(); PushStack([TQNodeWhileBlock node]); }
               | "until"  { UpdateToken(); PushStack([TQNodeUntilBlock node]); }
               )
               -- cond:Expression --
               {
                   ExtendToken();
                   [StackTop setCondition:cond];
                   PushStack([NSMutableArray array]);
               }
               ('{' -- ( Statement --)* '}' | -- Statement)
               {
                   ExtendToken();
                   NSMutableArray *statements = PopStack();
                   $$ = PopStack();
                   [$$ setStatements:statements];
               }


# Equations
Sum          = a:Product             { UpdateToken(); PushStack(a);                                                                             }
               ( - "+" - b:Product   { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorAdd      left:StackTop right:b]); }
               | - "-" - b:Product   { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorSubtract left:StackTop right:b]); }
               )*                    { $$ = PopStack();                                                                                         }

Product      = a:NoEqExpr            { UpdateToken(); PushStack(a);                                                                             }
               ( - "^"  - b:Product  { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorExponent left:StackTop right:b]); }
               | - "*"  - b:Product  { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorMultiply left:StackTop right:b]); }
               | - "/"  - b:Product  { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorDivide   left:StackTop right:b]); }
               | - ShiftRhs
               | - ".." - b:Product  { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorConcat   left:StackTop right:b]); }
               )*                    { $$ = PopStack();                                                                                         }
ShiftRhs     = "<<" - b:Product      { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorLShift   left:StackTop right:b]); }
             | ">>" - b:Product      { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorRShift   left:StackTop right:b]); }
## Shifts can also be used as statements (For example to push onto a stack or append to a string)
ShiftStmt    = a:NoEqExpr { PushStack(a); }
               - ShiftRhs { $$ = PopStack(); }

Equation     = a:Sum                 { UpdateToken(); PushStack(a);                                                                                   }
               ( - "<" -  b:Equation { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorLesser         left:StackTop right:b]); }
               | - ">" -  b:Equation { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorGreater        left:StackTop right:b]); }
               | - "<=" - b:Equation { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorLesserOrEqual  left:StackTop right:b]); }
               | - ">=" - b:Equation { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorGreaterOrEqual left:StackTop right:b]); }
               | - "==" - b:Equation { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorEqual          left:StackTop right:b]); }
               | - "!=" - b:Equation { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorInequal        left:StackTop right:b]); }
               )*                    { $$ = PopStack();                                                                                               }

Assignment     = a:AssgnLhs -   { UpdateToken(); PushStack(a);    }
                 (AssgnRhs -)+  { $$ = PopStack();                }
AssgnLhs       = Property
               | SubscriptExp
               | Variable
AssgnRhs       = -- ( "=" -- b:Expression { PushStack(b);                                                                       }
                 | "+=" -- b:Expression   { PushStack([TQNodeOperator nodeWithType:kTQOperatorAdd left:StackTop right:b]);      }
                 | "-=" -- b:Expression   { PushStack([TQNodeOperator nodeWithType:kTQOperatorSubtract left:StackTop right:b]); }
                 | "*=" -- b:Expression   { PushStack([TQNodeOperator nodeWithType:kTQOperatorMultiply left:StackTop right:b]); }
                 | "/=" -- b:Expression   { PushStack([TQNodeOperator nodeWithType:kTQOperatorDivide left:StackTop right:b]);   }
               )
               {
                   ExtendToken();
                   TQNodeOperator *assignVal = PopStack();
                   ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorAssign left:StackTop right:assignVal]);
               }

UnaryOp        = UnaryPrefixOp | UnaryMinusOp | UnaryPostfixOp
IncrDecrOp     = UnaryPrefixOp | UnaryPostfixOp

UnaryMinusOp   =  "-" a:AssgnLhs    { ExtendToken(); $$ = [TQNodeOperator nodeWithType:kTQOperatorUnaryMinus left:nil right:a]; }
               |  "-" a:ParenExpr   { ExtendToken(); $$ = [TQNodeOperator nodeWithType:kTQOperatorUnaryMinus left:nil right:a]; }

UnaryPrefixOp  = ( "++"             { ExtendToken(); PushStack([TQNodeOperator nodeWithType:kTQOperatorIncrement left:nil right:nil]);  }
                 | "--"             { ExtendToken(); PushStack([TQNodeOperator nodeWithType:kTQOperatorDecrement left:nil right:nil]);  }
                 )
                 a:AssgnLhs
                 {
                     $$ = PopStack();
                     [$$ setRight:a];
                 }

UnaryPostfixOp = a:AssgnLhs         { ExtendToken(); PushStack([TQNodeOperator nodeWithType:0 left:a right:nil]); }
                 ( "++"             { ExtendToken(); [(TQNodeOperator *)StackTop setType:kTQOperatorIncrement];   }
                 | "--"             { ExtendToken(); [(TQNodeOperator *)StackTop setType:kTQOperatorDecrement];   }
                 )
                 {
                     $$ = PopStack();
                 }


# Accessors

SubscriptExp = obj:SubscriptLhs
               {
                   UpdateToken();
                   PushStack([NSMutableArray array]);
               }
               - (Subscript -)+
               {
                   NSMutableArray *subscripts = PopStack();
                   $$ = [TQNodeOperator nodeWithType:kTQOperatorGetter left:obj right:[subscripts objectAtIndex:0]];
                   for(int i = 1; i < [subscripts count]; ++i) {
                      $$ = [TQNodeOperator nodeWithType:kTQOperatorGetter left:$$ right:[subscripts objectAtIndex:i]];
                   }

               }
SubscriptLhs = Property
             | Self
             | Variable
             | Constant
             | Variadic
             | ParenExpr
Subscript    = "[" -- subscript:Expression -- "]" { ExtendToken(); [StackTop addObject:subscript]; }

Property     = {
                   UpdateToken();
                   PushStack([TQNodeSelf node]);
               }
               (obj:PropLhs { ReplaceStackTop(obj); })?
               {
                   PushStack([NSMutableArray array]);
               }
               - (PropSubscr -)+
               {
                   NSMutableArray *subscripts = PopStack();
                   TQNode *receiver = PopStack();
                   $$ = [TQNodeMemberAccess nodeWithReceiver:receiver property:[subscripts objectAtIndex:0]];
                   for(int i = 1; i < [subscripts count]; ++i) {
                      $$ = [TQNodeMemberAccess nodeWithReceiver:$$ property:[subscripts objectAtIndex:i]];
                   }
               }
PropLhs      = Self
             | Variable
             | Constant

PropSubscr   = "#" - prop:Identifier { ExtendToken(); [StackTop addObject:prop]; }


# Built-in constructors
Array        = "#" ArrayProto
ArrayProto   = "["
               {
                   UpdateToken();
                   PushStack([NSMutableArray array]);
               }
               (ArrItem -- ("," -- ArrItem)*)?  -- "]"
               {
                   ExtendToken();
                   $$ = [TQNodeArray node];
                   NSMutableArray *items = PopStack();
                   [$$ setItems:items];
               }
ArrItem      = (subarray:ArrayProto
               {
                   [StackTop addObject:subarray];
               }
               | item:Expression
               {
                   [StackTop addObject:item];
               }
               )

Dictionary     = "#" DictProto
DictProto      = "{" --
               {
                   UpdateToken();
                   PushStack([NSMapTable mapTableWithStrongToStrongObjects]);
               }
               (DictItem -- ("," -- DictItem)*)? -- "}"
               {
                   $$ = [TQNodeDictionary node];
                   NSMutableArray *items = PopStack();
                   [$$ setItems:items];

               }
DictItem     = key:DictValue -- "=>" -- value:DictValue
               {
                   ExtendToken();
                   [StackTop setObject:value forKey:key];
               }
DictValue    = DictProto | Expression

# Basic components
Variable     = name:Identifier
               {
                   $$ = [TQNodeVariable nodeWithName:name];
               }

Literal      = Number
             | String
             | Array
             | Dictionary

BreakStmt    = 'break'                     { ExtendToken(); $$ = [TQNodeBreak node]; }
SkipStmt     = 'skip'                      { ExtendToken(); $$ = [TQNodeSkip node];  }
Nil          = ('nil' | 'no' | '('--')')   { ExtendToken(); $$ = [TQNodeNil node];   }
Self         = 'self'                      { ExtendToken(); $$ = [TQNodeSelf node];  }
Super        = 'super'                     { ExtendToken(); $$ = [TQNodeSuper node]; }
Variadic     = '...'                       { ExtendToken(); $$ = [TQNodeVariable nodeWithName:@"..."]; }
Valid        = ('valid'|'yes')             { ExtendToken(); $$ = [TQNodeValid node]; }

Operator     = '=='  { ExtendToken(); $$ = @"=="; }
             | '!='  { ExtendToken(); $$ = @"!="; }
             | '='   { ExtendToken(); $$ = @"=";  }
             | '>='  { ExtendToken(); $$ = @">="; }
             | '<='  { ExtendToken(); $$ = @"<="; }
             | '*'   { ExtendToken(); $$ = @"*";  }
             | '/'   { ExtendToken(); $$ = @"/";  }
             | '+'   { ExtendToken(); $$ = @"+";  }
             | '-'   { ExtendToken(); $$ = @"-";  }
             | '<<'  { ExtendToken(); $$ = @"<<"; }
             | '>>'  { ExtendToken(); $$ = @"<<"; }
             | '<'   { ExtendToken(); $$ = @"<";  }
             | '>'   { ExtendToken(); $$ = @">";  }
             | '..'  { ExtendToken(); $$ = @".."; }
             | '^'   { ExtendToken(); $$ = @"^";  }
             | '='   { ExtendToken(); $$ = @"=";  }
             | '[]'  { ExtendToken(); $$ = @"[]"; }


SelIdent     = Operator | Identifier

Number       = (< '-'? [0-9]+ ('.' [0-9]+)? ('e'[0-9]+)? >
             | < '-'? '.' [0-9]+ ('e'[0-9]+)? > )          { ExtendToken(); $$ = [TQNodeNumber nodeWithDouble:YYNUM];     }
Identifier   = < [a-z_] Character* >                       { ExtendToken(); $$ = YYNSSTR;                                 }
Constant     = < [A-Z] Character* >                        { ExtendToken(); $$ = [TQNodeConstant nodeWithString:YYNSSTR]; }
Character    = ([A-Za-z0-9_])

# String with support for embedding expressions
String       = '"'
               {
                   ExtendToken();
                   PushStack([TQNodeString nodeWithString:[NSMutableString string]]);
               }
               (StrEmbeddExpr|StrInside)* '"'
               {
                   $$ = PopStack();
               }

StrInside    = <("#" !"{" |[^\"#])+ >
               {
                   [[(TQNodeString *)StackTop value] appendString:YYNSSTR];
               }
StrEmbeddExpr= ("#{"-"}"
               | "#{" - expr:Expression - "}"
                 {
                     [[(TQNodeString *)StackTop value] appendString:@"%@"];
                     [[StackTop embeddedValues] addObject:expr];
                 }
               )
RegExp       = < "/" ("\\/"|[^/])* "/"[im]* >              { ExtendToken(); $$ = [TQNodeRegex nodeWithPattern:YYNSSTR];   }

Comment      = - (('\\') (!EOL .)* EOL)+

Space        = [ \t]
-            = Space*
--           = (Comment | EOL)? -
---          = (Space | EOL | Comment)+
EOL          = (- ('\n' | '\r\n' | '\r'))+
EOF          = - !.
%%

void printHelpAndExit(int status)
{
    printf("Usage: tranquil [options] [program path]\n");
    printf("-h    Show this help message\n");
    printf("-d    Print debugging information (Including the llvm assembly output)\n");
    exit(status);
}
int main(int argc, char **argv)
{
    BOOL showDebugOutput = NO;
    char *inputPath = NULL;

    char *arg;
    for(int i = 1; i < argc; ++i) {
        arg = argv[i];
        if(arg[0] == '-') {
            if(strcmp(arg, "-d") == 0) showDebugOutput = YES;
            else if(strcmp(arg, "-h") == 0) printHelpAndExit(0);
            else {
                fprintf(stderr, "Unknown argument %s\n", arg);
                printHelpAndExit(1);
            }
        } else
            inputPath = arg;
    }

    GREG greg;
    yyinit(&greg);

    TQParserState parserState = {0};
    parserState.currentLine = 1;
    parserState.stack = [NSMutableArray array];
    parserState.program = [TQProgram programWithName:@"Test"];
    parserState.program.shouldShowDebugInfo = showDebugOutput;
    parserState.stream = inputPath ? fopen(inputPath, "r") : stdin;
    if(!parserState.stream) {
        fprintf(stderr, "Input file '%s' not found", inputPath);
        exit(1);
    }
    greg.data = &parserState;

    [parserState.stack addObject:[NSMutableArray array]];

    while(yyparse(&greg));
    yydeinit(&greg);

    if(showDebugOutput)
        NSLog(@"%@", parserState.program);
    [parserState.program run];

    return 0;
}

