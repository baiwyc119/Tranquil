%{
#import <Tranquil/Tranquil.h>
#import <Tranquil/CodeGen/CodeGen.h>

struct _TQParserState {
    NSRange currentToken;
    NSUInteger currentLine;

    NSMutableArray *stack;
    TQNodeRootBlock *root;

    const char *script;
    unsigned int length, cursor;
};
typedef struct _TQParserState TQParserState;

#define YY_XTYPE TQParserState *
#define YY_XVAR  state
#define YYSTYPE id
#define YYNSSTR [NSMutableString stringWithUTF8String:yytext]
#define YYNUM atof(yytext)
#define YYNSNUM [NSNumber numberWithDouble:YYNUM]

#define StackTop [state->stack lastObject]
#define StackGet(ofs) [state->stack objectAtIndex:[state->stack count] + (ofs) - 1]
#define PushStack(obj) [state->stack addObject:(obj)]
#define PopStack() StackTop; [state->stack removeLastObject]
#define ReplaceStackTop(val) do { id repl = val; PopStack(); PushStack(repl); } while(0)

#define UpdateToken() do { \
    ((TQParserState *)state)->currentToken.location  = thunk->begin + G->offset;  \
    ((TQParserState *)state)->currentToken.length    = thunk->end - thunk->begin; \
} while(0)

#define CurrentLine ((TQParserState *)state)->currentLine
#define SetLineNo(node) [node setLineNumber:CurrentLine]

#define ExtendToken() do { \
    ((TQParserState *)state)->currentToken.length += thunk->end - thunk->begin; \
} while(0)

#define RewindWhitespace() for(; G->pos > 0 && (G->data->script[G->pos] == ' ' \
                                                || G->data->script[G->pos] == '\n' \
                                                || G->data->script[G->pos] == '\0'); --G->pos) { \
    if(G->data->script[G->pos] == '\n') \
        --G->data->currentLine; \
}

#define SyntaxError(msg) do { \
    RewindWhitespace(); \
    int lineNo = G->data->currentLine+1; \
    NSString *exceptionReason; \
    NSString *source         = [NSString stringWithFormat:@"%s", G->buf]; \
    NSRange tokRange         = state->currentToken; \
    NSRange srcRange         = NSMakeRange(0, [source length]); \
    NSRange interestingRange = NSIntersectionRange(srcRange, NSMakeRange(G->pos - 20, G->pos + 20)); \
    if(interestingRange.length > 0) { \
        NSMutableString *errStr = [[[source substringWithRange:interestingRange] mutableCopy] autorelease]; \
        const char *errCStr = [errStr UTF8String]; \
        \
        for(int i = G->pos; i <= [source length]; ++i) { \
            if(errCStr[i] == '\n' || errCStr[i] == '\0') { \
                int idx = i - interestingRange.location; \
                NSMutableString *spaceStr = [NSMutableString stringWithString:@"\n"]; \
                int temp = idx; \
                while(errCStr[temp] != '\n' && temp >= 0) { --temp; [spaceStr appendString:@" "]; } \
                [spaceStr replaceCharactersInRange:NSIntersectionRange(srcRange, (NSRange) { [spaceStr length]-2, 1}) withString:@"^"]; \
                [errStr insertString:spaceStr atIndex:idx]; \
                break; \
            } \
        } \
        exceptionReason = [NSString stringWithFormat:@"Line %d: Syntax error! %@ near:\n%@", lineNo, (msg), errStr]; \
    } else \
         exceptionReason = [NSString stringWithFormat:@"Line %d: Syntax error! %@", lineNo, (msg)]; \
    [NSException raise:kTQSyntaxErrorException format:@"%@", exceptionReason]; \
} while(0)

//#define YY_DEBUG

#define YY_INPUT(buf, result, maxSize, state) result = yyInput(buf, maxSize, state)

int yyInput(char *buf, int maxSize, TQParserState *state) {
    if(state->cursor >= state->length) {
        *buf = EOF;
        return 0;
    }
    *buf = state->script[state->cursor++];
    return 1;
}
%}

Program      = -- ((TopLevelStmt (- '.')?|Comment) --)+ EOF
               {
                   NSMutableArray *statements = PopStack();
                   TQNodeRootBlock *root = [TQNodeRootBlock node];
                   [root setStatements:statements];
                   state->root = root;
               }
             | - ( !EOL . )* EOL { SyntaxError(@"") }

TopLevelStmt = ImportStmt | Statement

# Import (can only appear in the top level)
ImportStmt   = "import" - path:String
             {
                 [StackTop addObject:[TQNodeImport nodeWithPath:[(TQNodeString *)path value]]];
             }

# Statement
Statement    = (
               Async
             | Wait
             | WhenFinished
             | Lock
             | If
             | Loop
             | BreakStmt
             | SkipStmt
             | ShiftStmt
             | CascadedMsg
             | Call
             | IncrDecrOp
             | Class
             | MultiAssgnmt
             | Assignment
             | Return
             | InvalidStmt
             )
             {
                 if(![$$ isKindOfClass:[NSArray class]]) {
                     //[$$ setLineNumber:CurrentLine];
                     [StackTop addObject:$$];
                 } else {
                     //for(TQNode *stmt in $$) [stmt setLineNumber:CurrentLine];
                     [StackTop addObjectsFromArray:$$];
                 }
             }

InvalidStmt  = Expression            { SyntaxError(@"Unexpected Expression"); }
             | ("=" -- b:Expression) { SyntaxError(@"Unexpected Assignment"); }

Return       = "^" retVal:Expression { UpdateToken(); $$ = [TQNodeReturn nodeWithValue:retVal]; }


# Expression
Expression   = TernaryExpr
             | KeywordMsg
             | Assignment
             | Equation
             | UnaryMsg
             | _OtherExpr
             {
                 //[$$ setLineNumber:CurrentLine];
             }

NoTernExpr   = Equation
             | _OtherExpr

NoEqExpr     = _OtherExpr

_OtherExpr   = UnaryMsg
             | Call
             | Valid
             | UnaryOp
             | Nil
             | SubscriptExp
             | Property
             | Self
             | Variadic
             | Literal
             | Block
             | Constant
             | Variable
             | Weak
             | ParenExpr

ParenExpr    = '(' -- expr:Expression -- ')' { ExtendToken(); $$ = expr; }


# Messages
UnaryMsg     = rcvr:UnaryMsgRcvr - {
                   ExtendToken();
                   PushStack([TQNodeMessage nodeWithReceiver:rcvr]);
               }
               body:UnaryMsgBody { $$ = PopStack(); SetLineNo($$); }

KeywordMsg   = rcvr:KwdMsgRcvr -
               {
                    ExtendToken();
                    PushStack([TQNodeMessage nodeWithReceiver:rcvr]);
                    SetLineNo(StackTop);
               }
               body:KwdMsgBody { $$ = PopStack(); }
CascadedMsg  = (KeywordMsg|UnaryMsg)
               {
                   PushStack($$);
               }
               (- ";" ---
                {
                    PushStack([TQNodeMessage node]);
                    SetLineNo(StackTop);
                }
                (UnaryMsgBody | KwdMsgBody)
                {
                    TQNodeMessage *msg = PopStack();
                    [[StackTop cascadedMessages] addObject:msg];
                })*
               {
                   $$ = PopStack();
               }

UnaryMsgRcvr = Call
             | SubscriptExp
             | Property
             | Constant
             | Super
             | Variadic
             | Literal
             | Block
             | Variable
             | Weak
             | ParenExpr
UnaryMsgBody =  name:Identifier - !":"
               {
                   [(NSMutableArray*)[StackTop arguments] addObject:[TQNodeArgument nodeWithPassedNode:nil
                                                                                           selectorPart:name]];
               }
               (- extraName:Identifier - !":"
                  {
                      ReplaceStackTop([TQNodeMessage nodeWithReceiver:StackTop]);
                      SetLineNo(StackTop);
                      [(NSMutableArray*)[StackTop arguments] addObject:[TQNodeArgument nodeWithPassedNode:nil
                                                                                             selectorPart:extraName]];

                  }
               )*


KwdMsgRcvr   = UnaryMsg
             | UnaryMsgRcvr
KwdMsgBody   = { PushStack([NSMutableArray array]); }
               (SelectorPart --)+
               {
                    ExtendToken();
                    $$ = PopStack();
                    [StackTop setArguments:$$];
               }
# One line keyword msg
OLKwdMsgBody = { PushStack([NSMutableArray array]); }
               (SelectorPart -)+
               {
                    ExtendToken();
                    $$ = PopStack();
                    [StackTop setArguments:$$];
               }


SelectorPart = { PushStack([TQNodeArgument node]); }
               (name:SelIdent  { [StackTop setSelectorPart:name]; })
                - ':' -- param:MessageArg
               {
                    ExtendToken();
                    TQNodeArgument *arg = PopStack();
                    [arg setPassedNode:param];
                    [StackTop addObject:arg];
               }
MessageArg   = TernaryExpr
             | Equation
             | Call
             | UnaryMsg
             | Block
             | UnaryOp
             | Nil
             | SubscriptExp
             | Property
             | RegExp
             | Self
             | Literal
             | Constant
             | Variable
             | ParenExpr

# Call
## callee(expr, expr)
Call         = callee:Callee
               {
                    ExtendToken();
                    PushStack([TQNodeCall nodeWithCallee:callee]);
                    SetLineNo(StackTop);
                    PushStack([NSMutableArray array]);
               }
               '(' -- (CallArg (-- ',' -- CallArg)*)? --
               _rightParen ~{ SyntaxError(@"Unterminated block call"); }
               {
                    ExtendToken();
                    NSMutableArray *arguments = PopStack();
                    $$ = PopStack();
                    [$$ setArguments:arguments];
               }
Callee       = Block
             | Constant
             | SubscriptExp
             | Property
             | Variable
             | Weak
CallArg      = arg:Expression { [StackTop addObject:arg]; }


# Block
Block        = '{' --
               {
                    UpdateToken();
                    PushStack([TQNodeBlock node]);
                    SetLineNo(StackTop);
                    PushStack([NSMutableArray array]);
               }
               ( ( (BlockArgDef - (',' -- BlockArgDef --)* (',' -- BlkVarArgDef --)?) | ( BlkVarArgDef --) )? '|' --)?
               {
                    ExtendToken();
                    NSMutableArray *arguments = PopStack();
                    for(TQNodeArgumentDef *arg in arguments) {
                       [StackTop addArgument:arg error:nil];
                    }
                    PushStack([NSMutableArray array]);
               }
               (Statement --)*
               {
                    NSMutableArray *statements = PopStack();
                    $$ = PopStack();
                    [$$ setStatements:statements];
               }
               _rightBrace ~{ SyntaxError(@"Unterminated block"); }
             | '`' -
               {
                   UpdateToken();
                   PushStack([NSMutableArray array]);
               }
               ( (BlockArgDef - (',' -- BlockArgDef --)*)?
               (',' -- BlkVarArgDef --)? -- '|' -)? expr:Expression -
               _backtick ~{ SyntaxError(@"Unterminated block"); }
               {
                   ExtendToken();
                   NSMutableArray *arguments = PopStack();
                   $$ = [TQNodeBlock node];
                   [$$ setIsCompactBlock:YES];
                   for(TQNodeArgumentDef *arg in arguments) {
                       [$$ addArgument:arg error:nil];
                   }
                   [$$ setStatements:[NSMutableArray arrayWithObject:[TQNodeReturn nodeWithValue:expr]]];
               }
BlockArgDef  = name:Identifier { [StackTop addObject:[TQNodeArgumentDef nodeWithName:name]]; }
                (- "=" --
                  default:Expression ~{ SyntaxError(@"Expected default argument expression after '='"); }
                  {
                      [[StackTop lastObject] setDefaultArgument:default];
                  })?
BlkVarArgDef = Variadic        { [StackGet(-1) setIsVariadic:YES]; }

# Concurrency
Async        = "async" - expr:Expression { $$ = [TQNodeAsync nodeWithExpression:expr]; SetLineNo($$); }
Wait         = "wait" { $$ = [TQNodeWait node]; SetLineNo($$); }
WhenFinished = "whenFinished" - expr:Expression { $$ = [TQNodeWhenFinished nodeWithExpression:expr]; SetLineNo($$); }
Lock         = "lock"  { PushStack([TQNodeLock node]); SetLineNo(StackTop); }
               -- cond:Expression --  ~{ SyntaxError(@"Lock condition missing"); }
               {
                   ExtendToken();
                   [StackTop setCondition:cond];
                   PushStack([NSMutableArray array]);
               }
               ('{' -- ( Statement --)*
                '}' ~{ SyntaxError(@"Unterminated lock"); }
               | -- Statement)
               {
                   ExtendToken();
                   NSMutableArray *statements = PopStack();
                   $$ = PopStack();
                   [$$ setStatements:statements];
               } 

# Class
Class        = '#' name:Constant --
               {
                   UpdateToken();
                   PushStack([TQNodeClass nodeWithName:[(TQNodeConstant *)name value]]);
                   SetLineNo(StackTop);
               }
               ( "<" --
                 SuperClsName ~{ SyntaxError(@"Expected Super class after '<'"); }
                 -- )?
               '{' -- (OnLoadMsg --)* (Method --)*
               _rightBrace ~{ SyntaxError(@"Unterminated class"); }
               {
                   ExtendToken();
                   $$ = PopStack();
               }
SuperClsName = superName:Constant
               {
                   ExtendToken();
                   SetLineNo(superName);
                   [StackTop setSuperClassName:[(TQNodeConstant *)superName value]];
               }
Method       = '+' -- method:MethodImpl
               {
                   ExtendToken();
                   [(TQNodeMethod *)method setType:kTQClassMethod];
                   [[(TQNodeClass *)StackTop classMethods] addObject:method];
               }
             | '-' -- method:MethodImpl
               {
                   ExtendToken();
                   [(TQNodeMethod *)method setType:kTQInstanceMethod];
                   [[(TQNodeClass *)StackTop instanceMethods] addObject:method];
               }
MethodImpl   = arguments:MethodArgs  --
               {
                   ExtendToken();
                   PushStack([NSMutableArray array]);
               }
               ( '{' -- (Statement --)*
                 _rightBrace ~{ SyntaxError(@"Unterminated method"); }
               {
                   NSMutableArray *statements = PopStack();
                   $$ = [TQNodeMethod node];
                   SetLineNo($$);
                   [$$ setStatements:statements];
               }
               | '`' - expr:Expression -
                 _backtick ~{ SyntaxError(@"Unterminated method"); }
               {
                   ExtendToken();
                   PopStack(); // Ignore
                   $$ = [TQNodeMethod node];
                   SetLineNo($$);
                   [$$ setStatements:[NSMutableArray arrayWithObject:[TQNodeReturn nodeWithValue:expr]]];
               }
               )
               {
                   NSError *err = nil;
                   for(TQNodeMethodArgumentDef *arg in arguments) {
                       [(TQNodeMethod*)$$ addArgument:arg error:&err];
                       if(err)
                           assert(false);
                   }
               }
MethodArgs   = selIdentifier:SelIdent
               {
                   ExtendToken();
                   PushStack([NSMutableArray array]);
                   [StackTop addObject:[TQNodeMethodArgumentDef nodeWithName:nil selectorPart:selIdentifier]];
               }
               (':' --
                name:Identifier ~{ SyntaxError(@"Missing parameter name"); }
                {
                    [[StackTop lastObject] setName:name];
                }
               -- MethodArg*)?
               {
                   ExtendToken();
                   $$ = PopStack();
               }
MethodArg    = identifier:SelIdent':' --
               name:Identifier ~{ SyntaxError(@"Missing parameter name"); }
               {
                   ExtendToken();
                   [StackTop addObject:[TQNodeMethodArgumentDef nodeWithName:name selectorPart:identifier]];
               }

OnLoadMsg    = { PushStack([TQNodeMessage nodeWithReceiver:StackTop]); SetLineNo(StackTop); }
               (OLKwdMsgBody | UnaryMsgBody)
               {
                   $$ = PopStack();
                   [[(TQNodeClass *)StackTop onLoadMessages] addObject:$$];
               }

# Conditionals
If           = ( "if"        { UpdateToken();  PushStack([TQNodeIfBlock node]);     SetLineNo(StackTop); }
               | "unless"    { UpdateToken();  PushStack([TQNodeUnlessBlock node]); SetLineNo(StackTop); }
               ) -
               cond:Expression ~{ SyntaxError(@"Condition missing"); }
               {
                   ExtendToken();
                   [StackTop setCondition:cond];
                   PushStack([NSMutableArray array]);
               }
               -- ('{' -- ( Statement --)*
                _rightBrace ~{ SyntaxError(@"Unterminated if/unless block"); }
               | -- Statement)
               ( -- "else" - elsif:If
                 {
                     [StackGet(-1) setElseStatements:[NSMutableArray arrayWithObject:elsif]];
                 }
               | -- "else" --
                 {
                     PushStack([NSMutableArray array]);
                 }
                 ("{" -- (Statement --)*
                  "}" ~{ SyntaxError(@"Unterminated else block"); }
                 | -- Statement)
                 {
                     NSMutableArray *statements = PopStack();
                     [StackGet(-1) setElseStatements:statements];
                 }
               )?
               {
                   ExtendToken();
                   NSMutableArray *statements = PopStack();
                   $$ = PopStack();
                   [$$ setIfStatements:statements];
               }

TernaryExpr    = cond:NoTernExpr --- "?" ---
                 ifExpr:Expression ~{ SyntaxError(@"Ternary expression missing non-nil case value"); }
                 {
                     PushStack([TQNodeTernaryOperator node]);
                     SetLineNo(StackTop);
                     [StackTop setCondition:cond];
                     [StackTop setIfExpr:ifExpr];
                 }
                 (--- ":" ---
                  elseExpr:Expression ~{ SyntaxError(@"Ternary expression missing nil case value"); }
                  {
                      [StackTop setElseExpr:elseExpr];
                  }
                 )?
                 {
                     $$ = PopStack();
                 }

# Loops

Loop         = ( "while"  { UpdateToken(); PushStack([TQNodeWhileBlock node]); SetLineNo(StackTop); }
               | "until"  { UpdateToken(); PushStack([TQNodeUntilBlock node]); SetLineNo(StackTop); }
               )
               -- cond:Expression --  ~{ SyntaxError(@"Loop condition missing"); }
               {
                   ExtendToken();
                   [StackTop setCondition:cond];
                   PushStack([NSMutableArray array]);
               }
               ('{' -- ( Statement --)*
                '}' ~{ SyntaxError(@"Unterminated loop"); }
               | -- Statement)
               {
                   ExtendToken();
                   NSMutableArray *statements = PopStack();
                   $$ = PopStack();
                   [$$ setStatements:statements];
               }


# Equations
Sum          = a:Product             { UpdateToken(); PushStack(a);                                                                             }
               ( - "+" - b:Product   { ExtendToken(); SetLineNo(StackTop); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorAdd      left:StackTop right:b]); }
               | - "-" - b:Product   { ExtendToken(); SetLineNo(StackTop); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorSubtract left:StackTop right:b]); }
               )*                    { $$ = PopStack(); SetLineNo($$);                                                                          }

Product      = a:NoEqExpr            { UpdateToken(); PushStack(a);                                                                             }
               ( - "^"  - b:Product  { ExtendToken(); SetLineNo(StackTop); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorExponent left:StackTop right:b]); }
               | - "*"  - b:Product  { ExtendToken(); SetLineNo(StackTop); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorMultiply left:StackTop right:b]); }
               | - "/"  - b:Product  { ExtendToken(); SetLineNo(StackTop); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorDivide   left:StackTop right:b]); }
               | - "%"  - b:Product  { ExtendToken(); SetLineNo(StackTop); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorModulo   left:StackTop right:b]); }
               | - ShiftRhs
               | - ".." - b:Product  { ExtendToken(); SetLineNo(StackTop); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorConcat   left:StackTop right:b]); }
               )*                    { $$ = PopStack(); SetLineNo($$);                                                                          }
ShiftRhs     = "<<" - b:Product      { ExtendToken(); SetLineNo(StackTop); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorLShift   left:StackTop right:b]); }
             | ">>" - b:Product      { ExtendToken(); SetLineNo(StackTop); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorRShift   left:StackTop right:b]); }
## Shifts can also be used as statements (For example to push onto a stack or append to a string)
ShiftStmt    = a:NoEqExpr { PushStack(a); }
               - ShiftRhs { $$ = PopStack(); SetLineNo($$); }

EqualityTest = a:Sum                 { UpdateToken(); PushStack(a);                                                                                   }
               ( - "<" -  b:Equation { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorLesser         left:StackTop right:b]); }
               | - ">" -  b:Equation { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorGreater        left:StackTop right:b]); }
               | - "<=" - b:Equation { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorLesserOrEqual  left:StackTop right:b]); }
               | - ">=" - b:Equation { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorGreaterOrEqual left:StackTop right:b]); }
               | - "==" - b:Equation { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorEqual          left:StackTop right:b]); }
               | - "!=" - b:Equation { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorInequal        left:StackTop right:b]); }
               )*                    { $$ = PopStack(); SetLineNo($$);                                                                                }

Equation     = a:EqualityTest        { UpdateToken(); PushStack(a);                                                                                   }
               ( - "&&" - b:Equation { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorAnd            left:StackTop right:b]); }
               | - "||" - b:Equation { ExtendToken(); ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorOr             left:StackTop right:b]); }
               )*                    { $$ = PopStack(); SetLineNo($$);                                                                                }

Assignment     = a:AssgnLhs - "=" - "async" - b:AssignValue
                 {
                     // `a = async { ..stmt.. }` means, assign to result of executing said block => Must convert to a call
                     // We have to do this here in the parser because `async a = { ..stmt.. }` does not mean the same thing
                     if([b isMemberOfClass:[TQNodeBlock class]])
                         b = [TQNodeCall nodeWithCallee:b];
                     PushStack([TQNodeOperator nodeWithType:kTQOperatorAssign left:a right:b]);
                     SetLineNo(StackTop);
                 }
                 - (AssgnRhs -)*  { id assgn = PopStack(); $$ = [TQNodeAsync nodeWithExpression:assgn]; }
               | a:AssgnLhs       { PushStack(a); }
                 - (AssgnRhs -)+  { $$ = PopStack(); }

AssgnLhs       = Property
               | SubscriptExp
               | Variable

AssgnRhs       = -- (  "=" -- b:AssignValue  { PushStack(b);                                                                       }
                    | "+=" -- b:Expression   { PushStack([TQNodeOperator nodeWithType:kTQOperatorAdd left:StackTop right:b]);      }
                    | "-=" -- b:Expression   { PushStack([TQNodeOperator nodeWithType:kTQOperatorSubtract left:StackTop right:b]); }
                    | "*=" -- b:Expression   { PushStack([TQNodeOperator nodeWithType:kTQOperatorMultiply left:StackTop right:b]); }
                    | "/=" -- b:Expression   { PushStack([TQNodeOperator nodeWithType:kTQOperatorDivide left:StackTop right:b]);   }
                    )
               {
                   ExtendToken();
                   TQNodeOperator *assignVal = PopStack();
                   ReplaceStackTop([TQNodeOperator nodeWithType:kTQOperatorAssign left:StackTop right:assignVal]);
                   SetLineNo(StackTop);
               }

MultiAssgnmt   = { PushStack([TQNodeMultiAssignOperator node]); SetLineNo(StackTop); }
                 MultiAsgnLhs (- "," -- MultiAsgnLhs)+ - "=" -- MultiAsgnRhs (- "," -- MultiAsgnRhs)*
                 {
                     $$ = PopStack();
                 }
MultiAsgnLhs   = AssgnLhs   { [[(TQNodeMultiAssignOperator *)StackTop left] addObject:$$]; }
MultiAsgnRhs   = Expression { [[(TQNodeMultiAssignOperator *)StackTop right] addObject:$$]; }

AssignValue    = CascadedMsg | Expression


UnaryOp        = UnaryPrefixOp | UnaryMinusOp | UnaryPostfixOp
IncrDecrOp     = UnaryPrefixOp | UnaryPostfixOp

UnaryMinusOp   =  "-" a:AssgnLhs    { ExtendToken(); $$ = [TQNodeOperator nodeWithType:kTQOperatorUnaryMinus left:nil right:a]; SetLineNo($$); }
               |  "-" a:ParenExpr   { ExtendToken(); $$ = [TQNodeOperator nodeWithType:kTQOperatorUnaryMinus left:nil right:a]; SetLineNo($$); }

UnaryPrefixOp  = ( "++"             { ExtendToken(); PushStack([TQNodeOperator nodeWithType:kTQOperatorIncrement left:nil right:nil]); }
                 | "--"             { ExtendToken(); PushStack([TQNodeOperator nodeWithType:kTQOperatorDecrement left:nil right:nil]); }
                 )
                 a:AssgnLhs
                 {
                     $$ = PopStack();
                     [$$ setRight:a];
                     SetLineNo($$);
                 }

UnaryPostfixOp = a:AssgnLhs         { ExtendToken(); PushStack([TQNodeOperator nodeWithType:0 left:a right:nil]); }
                 ( "++"             { ExtendToken(); [(TQNodeOperator *)StackTop setType:kTQOperatorIncrement];   }
                 | "--"             { ExtendToken(); [(TQNodeOperator *)StackTop setType:kTQOperatorDecrement];   }
                 )
                 {
                     $$ = PopStack();
                     SetLineNo($$);
                 }


# Accessors

SubscriptExp = obj:SubscriptLhs
               {
                   UpdateToken();
                   PushStack([NSMutableArray array]);
               }
               - (Subscript -)+
               {
                   NSMutableArray *subscripts = PopStack();
                   $$ = [TQNodeOperator nodeWithType:kTQOperatorGetter left:obj right:[subscripts objectAtIndex:0]];
                   SetLineNo($$);
                   for(int i = 1; i < [subscripts count]; ++i) {
                      $$ = [TQNodeOperator nodeWithType:kTQOperatorGetter left:$$ right:[subscripts objectAtIndex:i]];
                      SetLineNo($$);
                   }

               }
SubscriptLhs = Property
             | Self
             | Variable
             | Constant
             | Variadic
             | ParenExpr
Subscript    = "[" -- subscript:Expression --
               _rightBracket ~{ SyntaxError(@"Expected ']' to close subscript expression"); }
               { ExtendToken(); [StackTop addObject:subscript]; }

Property     = {
                   UpdateToken();
                   PushStack([TQNodeSelf node]);
                   SetLineNo(StackTop);
               }
               (obj:PropLhs { ReplaceStackTop(obj); })?
               {
                   PushStack([NSMutableArray array]);
               }
               (PropSubscr -)+
               {
                   NSMutableArray *subscripts = PopStack();
                   TQNode *receiver = PopStack();
                   $$ = [TQNodeMemberAccess nodeWithReceiver:receiver property:[subscripts objectAtIndex:0]];
                   SetLineNo($$);
                   for(int i = 1; i < [subscripts count]; ++i) {
                      $$ = [TQNodeMemberAccess nodeWithReceiver:$$ property:[subscripts objectAtIndex:i]];
                      SetLineNo($$);
                   }
               }
PropLhs      = Self
             | Variable
             | Constant

PropSubscr   = "#" - prop:Identifier { ExtendToken(); [StackTop addObject:prop]; }


# Built-in constructors
Array        = "[" --
               {
                   UpdateToken();
                   PushStack([NSMutableArray array]);
               }
               (ArrItem -- ("," --
                ArrItem ~{ SyntaxError(@"Expected array item after ','"); }
                )*)?  --
               _rightBracket ~{ SyntaxError(@"Array missing closing bracket"); }
               {
                   ExtendToken();
                   $$ = [TQNodeArray node];
                   SetLineNo($$);
                   NSMutableArray *items = PopStack();
                   [$$ setItems:items];
               }
ArrItem      = item:Expression
               {
                   [StackTop addObject:item];
               }

Dictionary   = "{" --
               {
                   UpdateToken();
                   PushStack([NSMapTable mapTableWithStrongToStrongObjects]);
               }
               (DictItem -- ("," -- DictItem)*)? --
               "}"
               {
                   $$ = [TQNodeDictionary node];
                   SetLineNo($$);
                   NSMutableArray *items = PopStack();
                   [$$ setItems:items];

               }
DictItem     = key:Expression -- "=>" --
               value:Expression ~{ SyntaxError(@"Expected dictionary item after '=>'"); }
               {
                   ExtendToken();
                   [StackTop setObject:value forKey:key];
               }

# Basic components
Variable     = name:Identifier
               {
                   $$ = [TQNodeVariable nodeWithName:name];
                   SetLineNo($$);
               }

Weak         = '~' --
               ( Block
               | UnaryOp
               | SubscriptExp
               | Property
               | Self
               | Variadic
               | Variable
               | ParenExpr) ~{ SyntaxError(@"Value for weak reference missing"); }
               {
                   $$ = [TQNodeWeak nodeWithValue:$$];
                   SetLineNo($$);
               }

Literal      = Number
             | String
             | Array
             | Dictionary
             | RegExp

BreakStmt    = 'break'                     { ExtendToken(); $$ = [TQNodeBreak node]; SetLineNo($$); }
SkipStmt     = 'skip'                      { ExtendToken(); $$ = [TQNodeSkip node];  SetLineNo($$); }
Nil          = ('nil' | 'no' | '('--')')   { ExtendToken(); $$ = [TQNodeNil node];   SetLineNo($$); }
Self         = 'self'                      { ExtendToken(); $$ = [TQNodeSelf node];  SetLineNo($$); }
Super        = 'super'                     { ExtendToken(); $$ = [TQNodeSuper node]; SetLineNo($$); }
Variadic     = '...'                       { ExtendToken(); $$ = [TQNodeVariable nodeWithName:@"..."]; SetLineNo($$); }
Valid        = ('valid'|'yes')             { ExtendToken(); $$ = [TQNodeValid node]; SetLineNo($$); }

Operator     = '=='  { ExtendToken(); $$ = @"=="; SetLineNo($$); }
             | '!='  { ExtendToken(); $$ = @"!="; SetLineNo($$); }
             | '='   { ExtendToken(); $$ = @"=";  SetLineNo($$); }
             | '>='  { ExtendToken(); $$ = @">="; SetLineNo($$); }
             | '<='  { ExtendToken(); $$ = @"<="; SetLineNo($$); }
             | '*'   { ExtendToken(); $$ = @"*";  SetLineNo($$); }
             | '/'   { ExtendToken(); $$ = @"/";  SetLineNo($$); }
             | '%'   { ExtendToken(); $$ = @"%";  SetLineNo($$); }
             | '+'   { ExtendToken(); $$ = @"+";  SetLineNo($$); }
             | '-'   { ExtendToken(); $$ = @"-";  SetLineNo($$); }
             | '<<'  { ExtendToken(); $$ = @"<<"; SetLineNo($$); }
             | '>>'  { ExtendToken(); $$ = @"<<"; SetLineNo($$); }
             | '<'   { ExtendToken(); $$ = @"<";  SetLineNo($$); }
             | '>'   { ExtendToken(); $$ = @">";  SetLineNo($$); }
             | '..'  { ExtendToken(); $$ = @".."; SetLineNo($$); }
             | '^'   { ExtendToken(); $$ = @"^";  SetLineNo($$); }
             | '='   { ExtendToken(); $$ = @"=";  SetLineNo($$); }
             | '[]'  { ExtendToken(); $$ = @"[]"; SetLineNo($$); }


SelIdent     = Operator | Identifier

Number       = (< '-'? [0-9]+ ('.' [0-9]+)? ('e'[0-9]+)? >
             | < '-'? '.' [0-9]+ ('e'[0-9]+)? > )          { ExtendToken(); $$ = [TQNodeNumber nodeWithDouble:YYNUM];     SetLineNo($$); }
Identifier   = < [a-z_] Character* >                       { ExtendToken(); $$ = YYNSSTR;                                 }
Constant     = < [A-Z] Character* >                        { ExtendToken(); $$ = [TQNodeConstant nodeWithString:YYNSSTR]; SetLineNo($$); }
Character    = ([A-Za-z0-9_])

# String with support for embedding expressions
String       = ConstString | MutableStr
MutableStr   = '"' { PushStack([TQNodeString nodeWithString:[NSMutableString string]]); SetLineNo(StackTop); }
               (StrEmbeddExpr|DQuotStrIn)*
               _dblQuot ~{ SyntaxError(@"String literal left unclosed"); }
               { $$ = PopStack(); }
             | "\'" { PushStack([TQNodeString nodeWithString:[NSMutableString string]]); SetLineNo(StackTop); }
               (StrEmbeddExpr|SQuotStrIn)*
               _snglQuot ~{ SyntaxError(@"String literal left unclosed"); }
               { $$ = PopStack(); }

DQuotStrIn   = <("#" !"{" |[^\"#])+ > { [(TQNodeString *)StackTop append:YYNSSTR]; }
SQuotStrIn   = <("#" !"{" |[^\'#])+ > { [(TQNodeString *)StackTop append:YYNSSTR]; }

StrEmbeddExpr= ("#{"-"}"
               | "#{" - expr:Expression - "}"
                 {
                     [(TQNodeString *)StackTop append:@"%@"];
                     [[StackTop embeddedValues] addObject:expr];
                 }
               )

# Constant string
ConstString  = "$" ( < [^\n ;]+ >
                   | '"' < [^\"]+ >
                     _dblQuot ~{ SyntaxError(@"Constant string literal left unclosed"); }
                   | "\'" < [^\']+ >
                     _snglQuot ~{ SyntaxError(@"Constant string literal left unclosed"); }
                   ) ~{ SyntaxError(@"Expected string literal after '$'"); }
                   { $$ = [TQNodeConstString nodeWithString:YYNSSTR]; SetLineNo($$); }

RegExp       = "/" { PushStack([TQNodeRegex nodeWithPattern:[NSMutableString stringWithString:@"/"]]); }
               (StrEmbeddExpr|RegexpIn)* <"/" [im]*>
             {
                 $$ = PopStack();
                 SetLineNo($$);
                 [(TQNodeRegex *)$$ append:YYNSSTR];
             }
RegexpIn     = < ("#" !"{" | "\\/" | [^\\/#])+ > { [(TQNodeRegex *)StackTop append:YYNSSTR]; }

Comment      = - (('\\') (!EOL .)* EOL)+

Space        = [ \t]
-            = Space*
--           = (Comment | EOL)? -
---          = (Space | EOL | Comment)+
EOL          = (- ('\n' | '\r\n' | '\r') { CurrentLine++; })+
EOF          = - !.

# Rules to implement syntax errors
_snglQuot     = "\'"
_dblQuot      = '"'
_backtick     = "`"
_rightParen   = ')'
_rightBrace   = "}"
_rightBracket = "]"
%%
